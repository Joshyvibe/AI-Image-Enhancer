from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework import status
from gradio_client import Client, handle_file
from django.conf import settings
import tempfile
import shutil
import re
from rest_framework.permissions import AllowAny
from django.core.files.storage import default_storage
import os
import cloudinary
import cloudinary.uploader


cloudinary.config(
    cloud_name= settings.CLOUDINARY['cloud_name'],
    api_key= settings.CLOUDINARY['api_key'],
    api_secret= settings.CLOUDINARY['api_secret']
)

def sanitize_filename(name):
    # Replace any invalid characters with underscores
    return re.sub(r'[^\w\-_\.]', '_', name)

class ImageRestoreView(APIView):
    parser_classes = [MultiPartParser, FormParser]  # To handle file uploads
    permission_classes = [AllowAny]  # Allow any user to access the view

    def post(self, request, *args, **kwargs):
        # Check if an image file is provided
        image_file = request.FILES.get('image')
        if not image_file:
            return Response({"error": "No image file provided."}, status=status.HTTP_400_BAD_REQUEST)

        # Save the file temporarily using Django's default storage
        file_path = default_storage.save(image_file.name, image_file)

        try:
            # Instantiate Gradio client
            client = Client("sczhou/CodeFormer")

            # Send the image to the Gradio client
            result = client.predict(
                image=handle_file(default_storage.path(file_path)),  # Pass the local file path
                face_align=True,
                background_enhance=True,
                face_upsample=True,
                upscale=2,
                codeformer_fidelity=0.5,
                api_name="/predict",
            )

            # Get the temporary file path generated by Gradio
            temp_file_path = result[0] if isinstance(result, tuple) else result
            print(f"Temporary file path: {temp_file_path}")
            print("Cloudinary Config:", cloudinary.config().cloud_name) # for debugging


            # Ensure the temp file exists
            if not os.path.exists(temp_file_path):
                return Response({"error": f"Temp file not found: {temp_file_path}"}, status=status.HTTP_400_BAD_REQUEST)

            # Move the file to a secure, universally accessible temporary directory
            secure_temp_dir = tempfile.gettempdir()
            secure_temp_path = os.path.join(secure_temp_dir, sanitize_filename("restored_image.webp"))
            shutil.copy(temp_file_path, secure_temp_path)

            # Generate a sanitized filename for the Cloudinary upload
            final_file_name = sanitize_filename(f"{os.path.splitext(image_file.name)[0]}.webp")

            # Upload the image directly to Cloudinary from the secure temp path
            print(f"Uploading to Cloudinary from: {secure_temp_path}")
            cloudinary_response = cloudinary.uploader.upload(
                secure_temp_path,
                public_id=final_file_name,
                folder="restored_images",
                resource_type="image"
            )

            print(f"Uploaded Image URL: {cloudinary_response['secure_url']}")
            # Clean up the secure temp file after upload
            os.remove(secure_temp_path)

            # Return the URL of the uploaded image from Cloudinary
            return Response({
                "image_url": cloudinary_response['secure_url']
            }, status=status.HTTP_200_OK)

        except Exception as e:
            print(f"Exception during upload: {e}")
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        finally:
            # Clean up the original temporary file uploaded via Django
            if os.path.exists(file_path):
                default_storage.delete(file_path)
